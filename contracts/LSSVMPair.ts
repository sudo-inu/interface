/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export interface LSSVMPairInterface extends utils.Interface {
  functions: {
    "assetRecipient()": FunctionFragment;
    "bondingCurve()": FunctionFragment;
    "call(address,bytes)": FunctionFragment;
    "changeAssetRecipient(address)": FunctionFragment;
    "changeDelta(uint128)": FunctionFragment;
    "changeFee(uint96)": FunctionFragment;
    "changeSpotPrice(uint128)": FunctionFragment;
    "delta()": FunctionFragment;
    "factory()": FunctionFragment;
    "fee()": FunctionFragment;
    "getAllHeldIds()": FunctionFragment;
    "getAssetRecipient()": FunctionFragment;
    "getBuyNFTQuote(uint256)": FunctionFragment;
    "getSellNFTQuote(uint256)": FunctionFragment;
    "initialize(address,address,uint128,uint96,uint128)": FunctionFragment;
    "multicall(bytes[],bool)": FunctionFragment;
    "nft()": FunctionFragment;
    "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)": FunctionFragment;
    "onERC1155Received(address,address,uint256,uint256,bytes)": FunctionFragment;
    "owner()": FunctionFragment;
    "pairVariant()": FunctionFragment;
    "poolType()": FunctionFragment;
    "spotPrice()": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "swapNFTsForToken(uint256[],uint256,address,bool,address)": FunctionFragment;
    "swapTokenForAnyNFTs(uint256,uint256,address,bool,address)": FunctionFragment;
    "swapTokenForSpecificNFTs(uint256[],uint256,address,bool,address)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "withdrawERC1155(address,uint256[],uint256[])": FunctionFragment;
    "withdrawERC20(address,uint256)": FunctionFragment;
    "withdrawERC721(address,uint256[])": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "assetRecipient"
      | "bondingCurve"
      | "call"
      | "changeAssetRecipient"
      | "changeDelta"
      | "changeFee"
      | "changeSpotPrice"
      | "delta"
      | "factory"
      | "fee"
      | "getAllHeldIds"
      | "getAssetRecipient"
      | "getBuyNFTQuote"
      | "getSellNFTQuote"
      | "initialize"
      | "multicall"
      | "nft"
      | "onERC1155BatchReceived"
      | "onERC1155Received"
      | "owner"
      | "pairVariant"
      | "poolType"
      | "spotPrice"
      | "supportsInterface"
      | "swapNFTsForToken"
      | "swapTokenForAnyNFTs"
      | "swapTokenForSpecificNFTs"
      | "transferOwnership"
      | "withdrawERC1155"
      | "withdrawERC20"
      | "withdrawERC721"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "assetRecipient",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "bondingCurve",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "call",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeAssetRecipient",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeDelta",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeFee",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "changeSpotPrice",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "delta", values?: undefined): string;
  encodeFunctionData(functionFragment: "factory", values?: undefined): string;
  encodeFunctionData(functionFragment: "fee", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getAllHeldIds",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getAssetRecipient",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBuyNFTQuote",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getSellNFTQuote",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "multicall",
    values: [PromiseOrValue<BytesLike>[], PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(functionFragment: "nft", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "onERC1155BatchReceived",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC1155Received",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "pairVariant",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "poolType", values?: undefined): string;
  encodeFunctionData(functionFragment: "spotPrice", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "swapNFTsForToken",
    values: [
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapTokenForAnyNFTs",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapTokenForSpecificNFTs",
    values: [
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawERC1155",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawERC20",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawERC721",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>[]]
  ): string;

  decodeFunctionResult(
    functionFragment: "assetRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bondingCurve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "call", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeAssetRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "changeDelta",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "changeFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "changeSpotPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "delta", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "factory", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getAllHeldIds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAssetRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBuyNFTQuote",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSellNFTQuote",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "multicall", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "nft", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155BatchReceived",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC1155Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pairVariant",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "poolType", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "spotPrice", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapNFTsForToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapTokenForAnyNFTs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapTokenForSpecificNFTs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawERC1155",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawERC721",
    data: BytesLike
  ): Result;

  events: {
    "AssetRecipientChange(address)": EventFragment;
    "DeltaUpdate(uint128)": EventFragment;
    "FeeUpdate(uint96)": EventFragment;
    "NFTWithdrawal()": EventFragment;
    "OwnershipTransferred(address)": EventFragment;
    "SpotPriceUpdate(uint128)": EventFragment;
    "SwapNFTInPair()": EventFragment;
    "SwapNFTOutPair()": EventFragment;
    "TokenDeposit(uint256)": EventFragment;
    "TokenWithdrawal(uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AssetRecipientChange"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DeltaUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FeeUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NFTWithdrawal"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SpotPriceUpdate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SwapNFTInPair"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SwapNFTOutPair"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenDeposit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenWithdrawal"): EventFragment;
}

export interface AssetRecipientChangeEventObject {
  a: string;
}
export type AssetRecipientChangeEvent = TypedEvent<
  [string],
  AssetRecipientChangeEventObject
>;

export type AssetRecipientChangeEventFilter =
  TypedEventFilter<AssetRecipientChangeEvent>;

export interface DeltaUpdateEventObject {
  newDelta: BigNumber;
}
export type DeltaUpdateEvent = TypedEvent<[BigNumber], DeltaUpdateEventObject>;

export type DeltaUpdateEventFilter = TypedEventFilter<DeltaUpdateEvent>;

export interface FeeUpdateEventObject {
  newFee: BigNumber;
}
export type FeeUpdateEvent = TypedEvent<[BigNumber], FeeUpdateEventObject>;

export type FeeUpdateEventFilter = TypedEventFilter<FeeUpdateEvent>;

export interface NFTWithdrawalEventObject {}
export type NFTWithdrawalEvent = TypedEvent<[], NFTWithdrawalEventObject>;

export type NFTWithdrawalEventFilter = TypedEventFilter<NFTWithdrawalEvent>;

export interface OwnershipTransferredEventObject {
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface SpotPriceUpdateEventObject {
  newSpotPrice: BigNumber;
}
export type SpotPriceUpdateEvent = TypedEvent<
  [BigNumber],
  SpotPriceUpdateEventObject
>;

export type SpotPriceUpdateEventFilter = TypedEventFilter<SpotPriceUpdateEvent>;

export interface SwapNFTInPairEventObject {}
export type SwapNFTInPairEvent = TypedEvent<[], SwapNFTInPairEventObject>;

export type SwapNFTInPairEventFilter = TypedEventFilter<SwapNFTInPairEvent>;

export interface SwapNFTOutPairEventObject {}
export type SwapNFTOutPairEvent = TypedEvent<[], SwapNFTOutPairEventObject>;

export type SwapNFTOutPairEventFilter = TypedEventFilter<SwapNFTOutPairEvent>;

export interface TokenDepositEventObject {
  amount: BigNumber;
}
export type TokenDepositEvent = TypedEvent<
  [BigNumber],
  TokenDepositEventObject
>;

export type TokenDepositEventFilter = TypedEventFilter<TokenDepositEvent>;

export interface TokenWithdrawalEventObject {
  amount: BigNumber;
}
export type TokenWithdrawalEvent = TypedEvent<
  [BigNumber],
  TokenWithdrawalEventObject
>;

export type TokenWithdrawalEventFilter = TypedEventFilter<TokenWithdrawalEvent>;

export interface LSSVMPair extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: LSSVMPairInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    assetRecipient(overrides?: CallOverrides): Promise<[string]>;

    bondingCurve(
      overrides?: CallOverrides
    ): Promise<[string] & { _bondingCurve: string }>;

    call(
      target: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    changeAssetRecipient(
      newRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    changeDelta(
      newDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    changeFee(
      newFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    changeSpotPrice(
      newSpotPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    delta(overrides?: CallOverrides): Promise<[BigNumber]>;

    factory(
      overrides?: CallOverrides
    ): Promise<[string] & { _factory: string }>;

    fee(overrides?: CallOverrides): Promise<[BigNumber]>;

    getAllHeldIds(overrides?: CallOverrides): Promise<[BigNumber[]]>;

    getAssetRecipient(
      overrides?: CallOverrides
    ): Promise<[string] & { _assetRecipient: string }>;

    getBuyNFTQuote(
      numNFTs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, BigNumber, BigNumber] & {
        error: number;
        newSpotPrice: BigNumber;
        newDelta: BigNumber;
        inputAmount: BigNumber;
        protocolFee: BigNumber;
      }
    >;

    getSellNFTQuote(
      numNFTs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, BigNumber, BigNumber] & {
        error: number;
        newSpotPrice: BigNumber;
        newDelta: BigNumber;
        outputAmount: BigNumber;
        protocolFee: BigNumber;
      }
    >;

    initialize(
      _owner: PromiseOrValue<string>,
      _assetRecipient: PromiseOrValue<string>,
      _delta: PromiseOrValue<BigNumberish>,
      _fee: PromiseOrValue<BigNumberish>,
      _spotPrice: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    multicall(
      calls: PromiseOrValue<BytesLike>[],
      revertOnFail: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    nft(overrides?: CallOverrides): Promise<[string] & { _nft: string }>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pairVariant(overrides?: CallOverrides): Promise<[number]>;

    poolType(
      overrides?: CallOverrides
    ): Promise<[number] & { _poolType: number }>;

    spotPrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    swapNFTsForToken(
      nftIds: PromiseOrValue<BigNumberish>[],
      minExpectedTokenOutput: PromiseOrValue<BigNumberish>,
      tokenRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    swapTokenForAnyNFTs(
      numNFTs: PromiseOrValue<BigNumberish>,
      maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
      nftRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    swapTokenForSpecificNFTs(
      nftIds: PromiseOrValue<BigNumberish>[],
      maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
      nftRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawERC1155(
      a: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawERC20(
      a: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawERC721(
      a: PromiseOrValue<string>,
      nftIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  assetRecipient(overrides?: CallOverrides): Promise<string>;

  bondingCurve(overrides?: CallOverrides): Promise<string>;

  call(
    target: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  changeAssetRecipient(
    newRecipient: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  changeDelta(
    newDelta: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  changeFee(
    newFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  changeSpotPrice(
    newSpotPrice: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  delta(overrides?: CallOverrides): Promise<BigNumber>;

  factory(overrides?: CallOverrides): Promise<string>;

  fee(overrides?: CallOverrides): Promise<BigNumber>;

  getAllHeldIds(overrides?: CallOverrides): Promise<BigNumber[]>;

  getAssetRecipient(overrides?: CallOverrides): Promise<string>;

  getBuyNFTQuote(
    numNFTs: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [number, BigNumber, BigNumber, BigNumber, BigNumber] & {
      error: number;
      newSpotPrice: BigNumber;
      newDelta: BigNumber;
      inputAmount: BigNumber;
      protocolFee: BigNumber;
    }
  >;

  getSellNFTQuote(
    numNFTs: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [number, BigNumber, BigNumber, BigNumber, BigNumber] & {
      error: number;
      newSpotPrice: BigNumber;
      newDelta: BigNumber;
      outputAmount: BigNumber;
      protocolFee: BigNumber;
    }
  >;

  initialize(
    _owner: PromiseOrValue<string>,
    _assetRecipient: PromiseOrValue<string>,
    _delta: PromiseOrValue<BigNumberish>,
    _fee: PromiseOrValue<BigNumberish>,
    _spotPrice: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  multicall(
    calls: PromiseOrValue<BytesLike>[],
    revertOnFail: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  nft(overrides?: CallOverrides): Promise<string>;

  onERC1155BatchReceived(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>[],
    arg3: PromiseOrValue<BigNumberish>[],
    arg4: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  onERC1155Received(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>,
    arg3: PromiseOrValue<BigNumberish>,
    arg4: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  pairVariant(overrides?: CallOverrides): Promise<number>;

  poolType(overrides?: CallOverrides): Promise<number>;

  spotPrice(overrides?: CallOverrides): Promise<BigNumber>;

  supportsInterface(
    interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  swapNFTsForToken(
    nftIds: PromiseOrValue<BigNumberish>[],
    minExpectedTokenOutput: PromiseOrValue<BigNumberish>,
    tokenRecipient: PromiseOrValue<string>,
    isRouter: PromiseOrValue<boolean>,
    routerCaller: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  swapTokenForAnyNFTs(
    numNFTs: PromiseOrValue<BigNumberish>,
    maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
    nftRecipient: PromiseOrValue<string>,
    isRouter: PromiseOrValue<boolean>,
    routerCaller: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  swapTokenForSpecificNFTs(
    nftIds: PromiseOrValue<BigNumberish>[],
    maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
    nftRecipient: PromiseOrValue<string>,
    isRouter: PromiseOrValue<boolean>,
    routerCaller: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawERC1155(
    a: PromiseOrValue<string>,
    ids: PromiseOrValue<BigNumberish>[],
    amounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawERC20(
    a: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawERC721(
    a: PromiseOrValue<string>,
    nftIds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    assetRecipient(overrides?: CallOverrides): Promise<string>;

    bondingCurve(overrides?: CallOverrides): Promise<string>;

    call(
      target: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    changeAssetRecipient(
      newRecipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    changeDelta(
      newDelta: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    changeFee(
      newFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    changeSpotPrice(
      newSpotPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    delta(overrides?: CallOverrides): Promise<BigNumber>;

    factory(overrides?: CallOverrides): Promise<string>;

    fee(overrides?: CallOverrides): Promise<BigNumber>;

    getAllHeldIds(overrides?: CallOverrides): Promise<BigNumber[]>;

    getAssetRecipient(overrides?: CallOverrides): Promise<string>;

    getBuyNFTQuote(
      numNFTs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, BigNumber, BigNumber] & {
        error: number;
        newSpotPrice: BigNumber;
        newDelta: BigNumber;
        inputAmount: BigNumber;
        protocolFee: BigNumber;
      }
    >;

    getSellNFTQuote(
      numNFTs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, BigNumber, BigNumber] & {
        error: number;
        newSpotPrice: BigNumber;
        newDelta: BigNumber;
        outputAmount: BigNumber;
        protocolFee: BigNumber;
      }
    >;

    initialize(
      _owner: PromiseOrValue<string>,
      _assetRecipient: PromiseOrValue<string>,
      _delta: PromiseOrValue<BigNumberish>,
      _fee: PromiseOrValue<BigNumberish>,
      _spotPrice: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    multicall(
      calls: PromiseOrValue<BytesLike>[],
      revertOnFail: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    nft(overrides?: CallOverrides): Promise<string>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    owner(overrides?: CallOverrides): Promise<string>;

    pairVariant(overrides?: CallOverrides): Promise<number>;

    poolType(overrides?: CallOverrides): Promise<number>;

    spotPrice(overrides?: CallOverrides): Promise<BigNumber>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    swapNFTsForToken(
      nftIds: PromiseOrValue<BigNumberish>[],
      minExpectedTokenOutput: PromiseOrValue<BigNumberish>,
      tokenRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    swapTokenForAnyNFTs(
      numNFTs: PromiseOrValue<BigNumberish>,
      maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
      nftRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    swapTokenForSpecificNFTs(
      nftIds: PromiseOrValue<BigNumberish>[],
      maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
      nftRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawERC1155(
      a: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawERC20(
      a: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawERC721(
      a: PromiseOrValue<string>,
      nftIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AssetRecipientChange(address)"(a?: null): AssetRecipientChangeEventFilter;
    AssetRecipientChange(a?: null): AssetRecipientChangeEventFilter;

    "DeltaUpdate(uint128)"(newDelta?: null): DeltaUpdateEventFilter;
    DeltaUpdate(newDelta?: null): DeltaUpdateEventFilter;

    "FeeUpdate(uint96)"(newFee?: null): FeeUpdateEventFilter;
    FeeUpdate(newFee?: null): FeeUpdateEventFilter;

    "NFTWithdrawal()"(): NFTWithdrawalEventFilter;
    NFTWithdrawal(): NFTWithdrawalEventFilter;

    "OwnershipTransferred(address)"(
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "SpotPriceUpdate(uint128)"(newSpotPrice?: null): SpotPriceUpdateEventFilter;
    SpotPriceUpdate(newSpotPrice?: null): SpotPriceUpdateEventFilter;

    "SwapNFTInPair()"(): SwapNFTInPairEventFilter;
    SwapNFTInPair(): SwapNFTInPairEventFilter;

    "SwapNFTOutPair()"(): SwapNFTOutPairEventFilter;
    SwapNFTOutPair(): SwapNFTOutPairEventFilter;

    "TokenDeposit(uint256)"(amount?: null): TokenDepositEventFilter;
    TokenDeposit(amount?: null): TokenDepositEventFilter;

    "TokenWithdrawal(uint256)"(amount?: null): TokenWithdrawalEventFilter;
    TokenWithdrawal(amount?: null): TokenWithdrawalEventFilter;
  };

  estimateGas: {
    assetRecipient(overrides?: CallOverrides): Promise<BigNumber>;

    bondingCurve(overrides?: CallOverrides): Promise<BigNumber>;

    call(
      target: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    changeAssetRecipient(
      newRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    changeDelta(
      newDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    changeFee(
      newFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    changeSpotPrice(
      newSpotPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    delta(overrides?: CallOverrides): Promise<BigNumber>;

    factory(overrides?: CallOverrides): Promise<BigNumber>;

    fee(overrides?: CallOverrides): Promise<BigNumber>;

    getAllHeldIds(overrides?: CallOverrides): Promise<BigNumber>;

    getAssetRecipient(overrides?: CallOverrides): Promise<BigNumber>;

    getBuyNFTQuote(
      numNFTs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getSellNFTQuote(
      numNFTs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      _owner: PromiseOrValue<string>,
      _assetRecipient: PromiseOrValue<string>,
      _delta: PromiseOrValue<BigNumberish>,
      _fee: PromiseOrValue<BigNumberish>,
      _spotPrice: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    multicall(
      calls: PromiseOrValue<BytesLike>[],
      revertOnFail: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    nft(overrides?: CallOverrides): Promise<BigNumber>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pairVariant(overrides?: CallOverrides): Promise<BigNumber>;

    poolType(overrides?: CallOverrides): Promise<BigNumber>;

    spotPrice(overrides?: CallOverrides): Promise<BigNumber>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    swapNFTsForToken(
      nftIds: PromiseOrValue<BigNumberish>[],
      minExpectedTokenOutput: PromiseOrValue<BigNumberish>,
      tokenRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    swapTokenForAnyNFTs(
      numNFTs: PromiseOrValue<BigNumberish>,
      maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
      nftRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    swapTokenForSpecificNFTs(
      nftIds: PromiseOrValue<BigNumberish>[],
      maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
      nftRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawERC1155(
      a: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawERC20(
      a: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawERC721(
      a: PromiseOrValue<string>,
      nftIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    assetRecipient(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bondingCurve(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    call(
      target: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    changeAssetRecipient(
      newRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    changeDelta(
      newDelta: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    changeFee(
      newFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    changeSpotPrice(
      newSpotPrice: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    delta(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    factory(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    fee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getAllHeldIds(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getAssetRecipient(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBuyNFTQuote(
      numNFTs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getSellNFTQuote(
      numNFTs: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      _owner: PromiseOrValue<string>,
      _assetRecipient: PromiseOrValue<string>,
      _delta: PromiseOrValue<BigNumberish>,
      _fee: PromiseOrValue<BigNumberish>,
      _spotPrice: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    multicall(
      calls: PromiseOrValue<BytesLike>[],
      revertOnFail: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    nft(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    onERC1155BatchReceived(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>[],
      arg3: PromiseOrValue<BigNumberish>[],
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    onERC1155Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BigNumberish>,
      arg4: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pairVariant(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    poolType(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    spotPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    swapNFTsForToken(
      nftIds: PromiseOrValue<BigNumberish>[],
      minExpectedTokenOutput: PromiseOrValue<BigNumberish>,
      tokenRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    swapTokenForAnyNFTs(
      numNFTs: PromiseOrValue<BigNumberish>,
      maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
      nftRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    swapTokenForSpecificNFTs(
      nftIds: PromiseOrValue<BigNumberish>[],
      maxExpectedTokenInput: PromiseOrValue<BigNumberish>,
      nftRecipient: PromiseOrValue<string>,
      isRouter: PromiseOrValue<boolean>,
      routerCaller: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawERC1155(
      a: PromiseOrValue<string>,
      ids: PromiseOrValue<BigNumberish>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawERC20(
      a: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawERC721(
      a: PromiseOrValue<string>,
      nftIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
